/* Kaylan Mettus
 * CS302-1002
 * Assignment 10
 * 
 * The implementation file for the huffman class */

#include "huffman.h"

//public functions
//constructor
huffman::huffman()
{
	for (int i = 0; i < SIZE; i++)
		counts[i] = 0;
	for (int j = 0; j < SIZE; j++)
		strCodes[j] = "";
	bits = "";
}

bool huffman::checkCompression(const std::string fileName)
{
	std::ifstream inFile;
	inFile.open(fileName.c_str());
	std::string line;
	int numChars = 0;
	
	//return false if the file couldn't be opened
	if (!inFile)
		return false;
	
	//count the chars in the file
	while (std::getline(inFile, line))
	{
		for (unsigned int i = 0; i < line.length(); i++)
		{
			counts[int(line[i])]++;
			numChars++;
		}
	}
	
	//build the tree
	buildTree();
	
	//output results
	printCodes();
	showStats(numChars);
	
	inFile.close();	
	return true;
}

//private functions
void huffman::buildTree()
{
	hNode *newNode, *min1, *min2, *root;
	int p1, p2, p;
	
	//make an empty priority queue
	priorityQueue<hNode *> minHeap;
	
	//create a new node for each nonzero character in the counts array
	//and add it into the priority queue
	for (int i = 0; i < SIZE; i++)
		if (counts[i] != 0)
		{
			newNode = new hNode;
			newNode->ch = char(i); 
			newNode->count = counts[i];
			newNode->left = NULL;
			newNode->right = NULL;
			
			minHeap.insert(newNode, newNode->count);
		}
		
	//remove two lowerst priority items, and create a new node with
	//summed count as the new count, then reinsert into priority queue
	//until only 1 element remains
	while (minHeap.entries() > 1)
	{
		minHeap.deleteMin(min1, p1);
		minHeap.deleteMin(min2, p2);
		
		newNode = new hNode;
		newNode->ch = 0;
		newNode->count = p1 + p2;
		newNode->left = min1;
		newNode->right = min2;
	
		minHeap.insert(newNode, newNode->count);
	}
	
	//remove the now finished tree from the priority queue
	minHeap.deleteMin(root, p);
	
	//determine bit codes for chars
	makeCodes(root, bits);
	
	//printTree(root);
		
}

void huffman::makeCodes(hNode *curr, std::string code)
{
	if (curr == NULL)
		return;
		
	//if leaf node, add code to strCodes array
	if (curr->ch != 0)
		strCodes[int(curr->ch)] = code;
	
	//add a 0 for every step left down the tree, 1 if going right
	makeCodes(curr->left, code += "0");
	makeCodes(curr->right, code += "1");
}

void huffman::printTree(hNode *curr)
{
	if (curr == NULL)
		return;
		
	std::cout << "|" << curr->ch << "|" << " " << curr->count << " " << std::endl;
	printTree(curr->left);
	printTree(curr->right);
}

void huffman::printCodes()
{
	for (int i = 0; i < SIZE; i++)
		if (strCodes[i] != "")
		{
			if (i < 32)
				//anything less than a space is printed with a special caharcter
				std::cout << "code[" << i << "] " << "\u2611" << " "
				<< strCodes[i] << std::endl;
			else
				std::cout << "code[" << i << "] " << char(i) << " "
				<< strCodes[i] << std::endl;
		}
}

void huffman::showStats(int num)
{
	int oldBits = 0, newBits = 0;
	
	//find total number of bits from original file and from the 
	//codes generated by huffman tree
	for (int i = 0; i < SIZE; i++)
	{
		oldBits += (8 * counts[i]);
		newBits += (strCodes[i].length() * counts[i]);
	}
		
	//find the compression ratio and percentage of space saved
	double compRatio = double(oldBits) / double(newBits);
	double savings = 100 * (double(newBits) / double(oldBits));
	
	std::cout << std::endl << "Original Chars:\t" << num << std::endl
	<< "New Bits Total:\t" << newBits << std::endl
	<< "Character Total:\t" << num << std::endl
	<< "Compression Ratio:\t" << compRatio << std::endl
	<< "Space Savings:\t" << savings << "%" << std::endl;
}
